/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#ifndef Hbase_H
#define Hbase_H

#include <TProcessor.h>
#include "hbase_types.h"

namespace apache { namespace hadoop { namespace hbase { namespace thrift {

class HbaseIf {
 public:
  virtual ~HbaseIf() {}
  virtual void enableTable(const Bytes& tableName) = 0;
  virtual void disableTable(const Bytes& tableName) = 0;
  virtual bool isTableEnabled(const Bytes& tableName) = 0;
  virtual void compact(const Bytes& tableNameOrRegionName) = 0;
  virtual void majorCompact(const Bytes& tableNameOrRegionName) = 0;
  virtual void getTableNames(std::vector<Text> & _return) = 0;
  virtual void getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return, const Text& tableName) = 0;
  virtual void getTableRegions(std::vector<TRegionInfo> & _return, const Text& tableName) = 0;
  virtual void createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies) = 0;
  virtual void deleteTable(const Text& tableName) = 0;
  virtual void get(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes) = 0;
  virtual void getVer(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions, const std::map<Text, Text> & attributes) = 0;
  virtual void getVerTs(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions, const std::map<Text, Text> & attributes) = 0;
  virtual void getRow(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) = 0;
  virtual void getRowWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;
  virtual void getRowTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void getRowWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void getRows(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::map<Text, Text> & attributes) = 0;
  virtual void getRowsWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;
  virtual void getRowsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void getRowsWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes) = 0;
  virtual void mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes) = 0;
  virtual void mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual int64_t atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value) = 0;
  virtual void deleteAll(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes) = 0;
  virtual void deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) = 0;
  virtual void increment(const TIncrement& increment) = 0;
  virtual void incrementRows(const std::vector<TIncrement> & increments) = 0;
  virtual void deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual ScannerID scannerOpenWithScan(const Text& tableName, const TScan& scan, const std::map<Text, Text> & attributes) = 0;
  virtual ScannerID scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;
  virtual ScannerID scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;
  virtual ScannerID scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;
  virtual ScannerID scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual ScannerID scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void scannerGet(std::vector<TRowResult> & _return, const ScannerID id) = 0;
  virtual void scannerGetList(std::vector<TRowResult> & _return, const ScannerID id, const int32_t nbRows) = 0;
  virtual void scannerClose(const ScannerID id) = 0;
  virtual void getRowOrBefore(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& family) = 0;
  virtual void getRegionInfo(TRegionInfo& _return, const Text& row) = 0;
};

class HbaseNull : virtual public HbaseIf {
 public:
  virtual ~HbaseNull() {}
  void enableTable(const Bytes& /* tableName */) {
    return;
  }
  void disableTable(const Bytes& /* tableName */) {
    return;
  }
  bool isTableEnabled(const Bytes& /* tableName */) {
    bool _return = false;
    return _return;
  }
  void compact(const Bytes& /* tableNameOrRegionName */) {
    return;
  }
  void majorCompact(const Bytes& /* tableNameOrRegionName */) {
    return;
  }
  void getTableNames(std::vector<Text> & /* _return */) {
    return;
  }
  void getColumnDescriptors(std::map<Text, ColumnDescriptor> & /* _return */, const Text& /* tableName */) {
    return;
  }
  void getTableRegions(std::vector<TRegionInfo> & /* _return */, const Text& /* tableName */) {
    return;
  }
  void createTable(const Text& /* tableName */, const std::vector<ColumnDescriptor> & /* columnFamilies */) {
    return;
  }
  void deleteTable(const Text& /* tableName */) {
    return;
  }
  void get(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getVer(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int32_t /* numVersions */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getVerTs(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int64_t /* timestamp */, const int32_t /* numVersions */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRow(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowWithColumns(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowWithColumnsTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRows(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowsWithColumns(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowsTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowsWithColumnsTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRow(const Text& /* tableName */, const Text& /* row */, const std::vector<Mutation> & /* mutations */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRowTs(const Text& /* tableName */, const Text& /* row */, const std::vector<Mutation> & /* mutations */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRows(const Text& /* tableName */, const std::vector<BatchMutation> & /* rowBatches */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRowsTs(const Text& /* tableName */, const std::vector<BatchMutation> & /* rowBatches */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  int64_t atomicIncrement(const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int64_t /* value */) {
    int64_t _return = 0;
    return _return;
  }
  void deleteAll(const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void deleteAllTs(const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void deleteAllRow(const Text& /* tableName */, const Text& /* row */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void increment(const TIncrement& /* increment */) {
    return;
  }
  void incrementRows(const std::vector<TIncrement> & /* increments */) {
    return;
  }
  void deleteAllRowTs(const Text& /* tableName */, const Text& /* row */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  ScannerID scannerOpenWithScan(const Text& /* tableName */, const TScan& /* scan */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpen(const Text& /* tableName */, const Text& /* startRow */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStop(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithPrefix(const Text& /* tableName */, const Text& /* startAndPrefix */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenTs(const Text& /* tableName */, const Text& /* startRow */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStopTs(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  void scannerGet(std::vector<TRowResult> & /* _return */, const ScannerID /* id */) {
    return;
  }
  void scannerGetList(std::vector<TRowResult> & /* _return */, const ScannerID /* id */, const int32_t /* nbRows */) {
    return;
  }
  void scannerClose(const ScannerID /* id */) {
    return;
  }
  void getRowOrBefore(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* family */) {
    return;
  }
  void getRegionInfo(TRegionInfo& /* _return */, const Text& /* row */) {
    return;
  }
};

class Hbase_enableTable_args {
 public:

  Hbase_enableTable_args() : tableName("") {
  }

  virtual ~Hbase_enableTable_args() throw() {}

  Bytes tableName;

  struct __isset {
    __isset() : tableName(false) {}
    bool tableName;
  } __isset;

  bool operator == (const Hbase_enableTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_enableTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_enableTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_enableTable_pargs {
 public:


  virtual ~Hbase_enableTable_pargs() throw() {}

  const Bytes* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_enableTable_result {
 public:

  Hbase_enableTable_result() {
  }

  virtual ~Hbase_enableTable_result() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  bool operator == (const Hbase_enableTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_enableTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_enableTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_enableTable_presult {
 public:


  virtual ~Hbase_enableTable_presult() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_disableTable_args {
 public:

  Hbase_disableTable_args() : tableName("") {
  }

  virtual ~Hbase_disableTable_args() throw() {}

  Bytes tableName;

  struct __isset {
    __isset() : tableName(false) {}
    bool tableName;
  } __isset;

  bool operator == (const Hbase_disableTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_disableTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_disableTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_disableTable_pargs {
 public:


  virtual ~Hbase_disableTable_pargs() throw() {}

  const Bytes* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_disableTable_result {
 public:

  Hbase_disableTable_result() {
  }

  virtual ~Hbase_disableTable_result() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  bool operator == (const Hbase_disableTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_disableTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_disableTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_disableTable_presult {
 public:


  virtual ~Hbase_disableTable_presult() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_isTableEnabled_args {
 public:

  Hbase_isTableEnabled_args() : tableName("") {
  }

  virtual ~Hbase_isTableEnabled_args() throw() {}

  Bytes tableName;

  struct __isset {
    __isset() : tableName(false) {}
    bool tableName;
  } __isset;

  bool operator == (const Hbase_isTableEnabled_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_isTableEnabled_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_isTableEnabled_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_isTableEnabled_pargs {
 public:


  virtual ~Hbase_isTableEnabled_pargs() throw() {}

  const Bytes* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_isTableEnabled_result {
 public:

  Hbase_isTableEnabled_result() : success(0) {
  }

  virtual ~Hbase_isTableEnabled_result() throw() {}

  bool success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_isTableEnabled_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_isTableEnabled_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_isTableEnabled_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_isTableEnabled_presult {
 public:


  virtual ~Hbase_isTableEnabled_presult() throw() {}

  bool* success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_compact_args {
 public:

  Hbase_compact_args() : tableNameOrRegionName("") {
  }

  virtual ~Hbase_compact_args() throw() {}

  Bytes tableNameOrRegionName;

  struct __isset {
    __isset() : tableNameOrRegionName(false) {}
    bool tableNameOrRegionName;
  } __isset;

  bool operator == (const Hbase_compact_args & rhs) const
  {
    if (!(tableNameOrRegionName == rhs.tableNameOrRegionName))
      return false;
    return true;
  }
  bool operator != (const Hbase_compact_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_compact_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_compact_pargs {
 public:


  virtual ~Hbase_compact_pargs() throw() {}

  const Bytes* tableNameOrRegionName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_compact_result {
 public:

  Hbase_compact_result() {
  }

  virtual ~Hbase_compact_result() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  bool operator == (const Hbase_compact_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_compact_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_compact_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_compact_presult {
 public:


  virtual ~Hbase_compact_presult() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_majorCompact_args {
 public:

  Hbase_majorCompact_args() : tableNameOrRegionName("") {
  }

  virtual ~Hbase_majorCompact_args() throw() {}

  Bytes tableNameOrRegionName;

  struct __isset {
    __isset() : tableNameOrRegionName(false) {}
    bool tableNameOrRegionName;
  } __isset;

  bool operator == (const Hbase_majorCompact_args & rhs) const
  {
    if (!(tableNameOrRegionName == rhs.tableNameOrRegionName))
      return false;
    return true;
  }
  bool operator != (const Hbase_majorCompact_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_majorCompact_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_majorCompact_pargs {
 public:


  virtual ~Hbase_majorCompact_pargs() throw() {}

  const Bytes* tableNameOrRegionName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_majorCompact_result {
 public:

  Hbase_majorCompact_result() {
  }

  virtual ~Hbase_majorCompact_result() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  bool operator == (const Hbase_majorCompact_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_majorCompact_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_majorCompact_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_majorCompact_presult {
 public:


  virtual ~Hbase_majorCompact_presult() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getTableNames_args {
 public:

  Hbase_getTableNames_args() {
  }

  virtual ~Hbase_getTableNames_args() throw() {}


  bool operator == (const Hbase_getTableNames_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Hbase_getTableNames_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableNames_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getTableNames_pargs {
 public:


  virtual ~Hbase_getTableNames_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getTableNames_result {
 public:

  Hbase_getTableNames_result() {
  }

  virtual ~Hbase_getTableNames_result() throw() {}

  std::vector<Text>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getTableNames_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getTableNames_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableNames_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getTableNames_presult {
 public:


  virtual ~Hbase_getTableNames_presult() throw() {}

  std::vector<Text> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getColumnDescriptors_args {
 public:

  Hbase_getColumnDescriptors_args() : tableName("") {
  }

  virtual ~Hbase_getColumnDescriptors_args() throw() {}

  Text tableName;

  struct __isset {
    __isset() : tableName(false) {}
    bool tableName;
  } __isset;

  bool operator == (const Hbase_getColumnDescriptors_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_getColumnDescriptors_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getColumnDescriptors_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getColumnDescriptors_pargs {
 public:


  virtual ~Hbase_getColumnDescriptors_pargs() throw() {}

  const Text* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getColumnDescriptors_result {
 public:

  Hbase_getColumnDescriptors_result() {
  }

  virtual ~Hbase_getColumnDescriptors_result() throw() {}

  std::map<Text, ColumnDescriptor>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getColumnDescriptors_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getColumnDescriptors_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getColumnDescriptors_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getColumnDescriptors_presult {
 public:


  virtual ~Hbase_getColumnDescriptors_presult() throw() {}

  std::map<Text, ColumnDescriptor> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getTableRegions_args {
 public:

  Hbase_getTableRegions_args() : tableName("") {
  }

  virtual ~Hbase_getTableRegions_args() throw() {}

  Text tableName;

  struct __isset {
    __isset() : tableName(false) {}
    bool tableName;
  } __isset;

  bool operator == (const Hbase_getTableRegions_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_getTableRegions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableRegions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getTableRegions_pargs {
 public:


  virtual ~Hbase_getTableRegions_pargs() throw() {}

  const Text* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getTableRegions_result {
 public:

  Hbase_getTableRegions_result() {
  }

  virtual ~Hbase_getTableRegions_result() throw() {}

  std::vector<TRegionInfo>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getTableRegions_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getTableRegions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableRegions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getTableRegions_presult {
 public:


  virtual ~Hbase_getTableRegions_presult() throw() {}

  std::vector<TRegionInfo> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_createTable_args {
 public:

  Hbase_createTable_args() : tableName("") {
  }

  virtual ~Hbase_createTable_args() throw() {}

  Text tableName;
  std::vector<ColumnDescriptor>  columnFamilies;

  struct __isset {
    __isset() : tableName(false), columnFamilies(false) {}
    bool tableName;
    bool columnFamilies;
  } __isset;

  bool operator == (const Hbase_createTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(columnFamilies == rhs.columnFamilies))
      return false;
    return true;
  }
  bool operator != (const Hbase_createTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_createTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_createTable_pargs {
 public:


  virtual ~Hbase_createTable_pargs() throw() {}

  const Text* tableName;
  const std::vector<ColumnDescriptor> * columnFamilies;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_createTable_result {
 public:

  Hbase_createTable_result() {
  }

  virtual ~Hbase_createTable_result() throw() {}

  IOError io;
  IllegalArgument ia;
  AlreadyExists exist;

  struct __isset {
    __isset() : io(false), ia(false), exist(false) {}
    bool io;
    bool ia;
    bool exist;
  } __isset;

  bool operator == (const Hbase_createTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    if (!(exist == rhs.exist))
      return false;
    return true;
  }
  bool operator != (const Hbase_createTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_createTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_createTable_presult {
 public:


  virtual ~Hbase_createTable_presult() throw() {}

  IOError io;
  IllegalArgument ia;
  AlreadyExists exist;

  struct __isset {
    __isset() : io(false), ia(false), exist(false) {}
    bool io;
    bool ia;
    bool exist;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_deleteTable_args {
 public:

  Hbase_deleteTable_args() : tableName("") {
  }

  virtual ~Hbase_deleteTable_args() throw() {}

  Text tableName;

  struct __isset {
    __isset() : tableName(false) {}
    bool tableName;
  } __isset;

  bool operator == (const Hbase_deleteTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteTable_pargs {
 public:


  virtual ~Hbase_deleteTable_pargs() throw() {}

  const Text* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteTable_result {
 public:

  Hbase_deleteTable_result() {
  }

  virtual ~Hbase_deleteTable_result() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  bool operator == (const Hbase_deleteTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteTable_presult {
 public:


  virtual ~Hbase_deleteTable_presult() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_get_args {
 public:

  Hbase_get_args() : tableName(""), row(""), column("") {
  }

  virtual ~Hbase_get_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), column(false), attributes(false) {}
    bool tableName;
    bool row;
    bool column;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_get_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_get_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_get_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_get_pargs {
 public:


  virtual ~Hbase_get_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_get_result {
 public:

  Hbase_get_result() {
  }

  virtual ~Hbase_get_result() throw() {}

  std::vector<TCell>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_get_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_get_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_get_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_get_presult {
 public:


  virtual ~Hbase_get_presult() throw() {}

  std::vector<TCell> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getVer_args {
 public:

  Hbase_getVer_args() : tableName(""), row(""), column(""), numVersions(0) {
  }

  virtual ~Hbase_getVer_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  int32_t numVersions;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), column(false), numVersions(false), attributes(false) {}
    bool tableName;
    bool row;
    bool column;
    bool numVersions;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_getVer_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(numVersions == rhs.numVersions))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getVer_pargs {
 public:


  virtual ~Hbase_getVer_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const int32_t* numVersions;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getVer_result {
 public:

  Hbase_getVer_result() {
  }

  virtual ~Hbase_getVer_result() throw() {}

  std::vector<TCell>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getVer_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getVer_presult {
 public:


  virtual ~Hbase_getVer_presult() throw() {}

  std::vector<TCell> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getVerTs_args {
 public:

  Hbase_getVerTs_args() : tableName(""), row(""), column(""), timestamp(0), numVersions(0) {
  }

  virtual ~Hbase_getVerTs_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  int64_t timestamp;
  int32_t numVersions;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), column(false), timestamp(false), numVersions(false), attributes(false) {}
    bool tableName;
    bool row;
    bool column;
    bool timestamp;
    bool numVersions;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_getVerTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(numVersions == rhs.numVersions))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVerTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVerTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getVerTs_pargs {
 public:


  virtual ~Hbase_getVerTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const int64_t* timestamp;
  const int32_t* numVersions;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getVerTs_result {
 public:

  Hbase_getVerTs_result() {
  }

  virtual ~Hbase_getVerTs_result() throw() {}

  std::vector<TCell>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getVerTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVerTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVerTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getVerTs_presult {
 public:


  virtual ~Hbase_getVerTs_presult() throw() {}

  std::vector<TCell> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getRow_args {
 public:

  Hbase_getRow_args() : tableName(""), row("") {
  }

  virtual ~Hbase_getRow_args() throw() {}

  Text tableName;
  Text row;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), attributes(false) {}
    bool tableName;
    bool row;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_getRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRow_pargs {
 public:


  virtual ~Hbase_getRow_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRow_result {
 public:

  Hbase_getRow_result() {
  }

  virtual ~Hbase_getRow_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getRow_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRow_presult {
 public:


  virtual ~Hbase_getRow_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getRowWithColumns_args {
 public:

  Hbase_getRowWithColumns_args() : tableName(""), row("") {
  }

  virtual ~Hbase_getRowWithColumns_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), columns(false), attributes(false) {}
    bool tableName;
    bool row;
    bool columns;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_getRowWithColumns_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumns_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumns_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowWithColumns_pargs {
 public:


  virtual ~Hbase_getRowWithColumns_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowWithColumns_result {
 public:

  Hbase_getRowWithColumns_result() {
  }

  virtual ~Hbase_getRowWithColumns_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getRowWithColumns_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumns_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumns_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowWithColumns_presult {
 public:


  virtual ~Hbase_getRowWithColumns_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getRowTs_args {
 public:

  Hbase_getRowTs_args() : tableName(""), row(""), timestamp(0) {
  }

  virtual ~Hbase_getRowTs_args() throw() {}

  Text tableName;
  Text row;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), timestamp(false), attributes(false) {}
    bool tableName;
    bool row;
    bool timestamp;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_getRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowTs_pargs {
 public:


  virtual ~Hbase_getRowTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowTs_result {
 public:

  Hbase_getRowTs_result() {
  }

  virtual ~Hbase_getRowTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getRowTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowTs_presult {
 public:


  virtual ~Hbase_getRowTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getRowWithColumnsTs_args {
 public:

  Hbase_getRowWithColumnsTs_args() : tableName(""), row(""), timestamp(0) {
  }

  virtual ~Hbase_getRowWithColumnsTs_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Text>  columns;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), columns(false), timestamp(false), attributes(false) {}
    bool tableName;
    bool row;
    bool columns;
    bool timestamp;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_getRowWithColumnsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumnsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumnsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowWithColumnsTs_pargs {
 public:


  virtual ~Hbase_getRowWithColumnsTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Text> * columns;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowWithColumnsTs_result {
 public:

  Hbase_getRowWithColumnsTs_result() {
  }

  virtual ~Hbase_getRowWithColumnsTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getRowWithColumnsTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumnsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumnsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowWithColumnsTs_presult {
 public:


  virtual ~Hbase_getRowWithColumnsTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getRows_args {
 public:

  Hbase_getRows_args() : tableName("") {
  }

  virtual ~Hbase_getRows_args() throw() {}

  Text tableName;
  std::vector<Text>  rows;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), rows(false), attributes(false) {}
    bool tableName;
    bool rows;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_getRows_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRows_pargs {
 public:


  virtual ~Hbase_getRows_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * rows;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRows_result {
 public:

  Hbase_getRows_result() {
  }

  virtual ~Hbase_getRows_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getRows_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRows_presult {
 public:


  virtual ~Hbase_getRows_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getRowsWithColumns_args {
 public:

  Hbase_getRowsWithColumns_args() : tableName("") {
  }

  virtual ~Hbase_getRowsWithColumns_args() throw() {}

  Text tableName;
  std::vector<Text>  rows;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), rows(false), columns(false), attributes(false) {}
    bool tableName;
    bool rows;
    bool columns;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_getRowsWithColumns_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumns_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumns_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowsWithColumns_pargs {
 public:


  virtual ~Hbase_getRowsWithColumns_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * rows;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowsWithColumns_result {
 public:

  Hbase_getRowsWithColumns_result() {
  }

  virtual ~Hbase_getRowsWithColumns_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getRowsWithColumns_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumns_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumns_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowsWithColumns_presult {
 public:


  virtual ~Hbase_getRowsWithColumns_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getRowsTs_args {
 public:

  Hbase_getRowsTs_args() : tableName(""), timestamp(0) {
  }

  virtual ~Hbase_getRowsTs_args() throw() {}

  Text tableName;
  std::vector<Text>  rows;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), rows(false), timestamp(false), attributes(false) {}
    bool tableName;
    bool rows;
    bool timestamp;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_getRowsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowsTs_pargs {
 public:


  virtual ~Hbase_getRowsTs_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * rows;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowsTs_result {
 public:

  Hbase_getRowsTs_result() {
  }

  virtual ~Hbase_getRowsTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getRowsTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowsTs_presult {
 public:


  virtual ~Hbase_getRowsTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getRowsWithColumnsTs_args {
 public:

  Hbase_getRowsWithColumnsTs_args() : tableName(""), timestamp(0) {
  }

  virtual ~Hbase_getRowsWithColumnsTs_args() throw() {}

  Text tableName;
  std::vector<Text>  rows;
  std::vector<Text>  columns;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), rows(false), columns(false), timestamp(false), attributes(false) {}
    bool tableName;
    bool rows;
    bool columns;
    bool timestamp;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_getRowsWithColumnsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumnsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumnsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowsWithColumnsTs_pargs {
 public:


  virtual ~Hbase_getRowsWithColumnsTs_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * rows;
  const std::vector<Text> * columns;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowsWithColumnsTs_result {
 public:

  Hbase_getRowsWithColumnsTs_result() {
  }

  virtual ~Hbase_getRowsWithColumnsTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getRowsWithColumnsTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumnsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumnsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowsWithColumnsTs_presult {
 public:


  virtual ~Hbase_getRowsWithColumnsTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_mutateRow_args {
 public:

  Hbase_mutateRow_args() : tableName(""), row("") {
  }

  virtual ~Hbase_mutateRow_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Mutation>  mutations;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), mutations(false), attributes(false) {}
    bool tableName;
    bool row;
    bool mutations;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_mutateRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_mutateRow_pargs {
 public:


  virtual ~Hbase_mutateRow_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Mutation> * mutations;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_mutateRow_result {
 public:

  Hbase_mutateRow_result() {
  }

  virtual ~Hbase_mutateRow_result() throw() {}

  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : io(false), ia(false) {}
    bool io;
    bool ia;
  } __isset;

  bool operator == (const Hbase_mutateRow_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_mutateRow_presult {
 public:


  virtual ~Hbase_mutateRow_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : io(false), ia(false) {}
    bool io;
    bool ia;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_mutateRowTs_args {
 public:

  Hbase_mutateRowTs_args() : tableName(""), row(""), timestamp(0) {
  }

  virtual ~Hbase_mutateRowTs_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Mutation>  mutations;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), mutations(false), timestamp(false), attributes(false) {}
    bool tableName;
    bool row;
    bool mutations;
    bool timestamp;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_mutateRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_mutateRowTs_pargs {
 public:


  virtual ~Hbase_mutateRowTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Mutation> * mutations;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_mutateRowTs_result {
 public:

  Hbase_mutateRowTs_result() {
  }

  virtual ~Hbase_mutateRowTs_result() throw() {}

  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : io(false), ia(false) {}
    bool io;
    bool ia;
  } __isset;

  bool operator == (const Hbase_mutateRowTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_mutateRowTs_presult {
 public:


  virtual ~Hbase_mutateRowTs_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : io(false), ia(false) {}
    bool io;
    bool ia;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_mutateRows_args {
 public:

  Hbase_mutateRows_args() : tableName("") {
  }

  virtual ~Hbase_mutateRows_args() throw() {}

  Text tableName;
  std::vector<BatchMutation>  rowBatches;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), rowBatches(false), attributes(false) {}
    bool tableName;
    bool rowBatches;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_mutateRows_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rowBatches == rhs.rowBatches))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_mutateRows_pargs {
 public:


  virtual ~Hbase_mutateRows_pargs() throw() {}

  const Text* tableName;
  const std::vector<BatchMutation> * rowBatches;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_mutateRows_result {
 public:

  Hbase_mutateRows_result() {
  }

  virtual ~Hbase_mutateRows_result() throw() {}

  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : io(false), ia(false) {}
    bool io;
    bool ia;
  } __isset;

  bool operator == (const Hbase_mutateRows_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_mutateRows_presult {
 public:


  virtual ~Hbase_mutateRows_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : io(false), ia(false) {}
    bool io;
    bool ia;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_mutateRowsTs_args {
 public:

  Hbase_mutateRowsTs_args() : tableName(""), timestamp(0) {
  }

  virtual ~Hbase_mutateRowsTs_args() throw() {}

  Text tableName;
  std::vector<BatchMutation>  rowBatches;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), rowBatches(false), timestamp(false), attributes(false) {}
    bool tableName;
    bool rowBatches;
    bool timestamp;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_mutateRowsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rowBatches == rhs.rowBatches))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_mutateRowsTs_pargs {
 public:


  virtual ~Hbase_mutateRowsTs_pargs() throw() {}

  const Text* tableName;
  const std::vector<BatchMutation> * rowBatches;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_mutateRowsTs_result {
 public:

  Hbase_mutateRowsTs_result() {
  }

  virtual ~Hbase_mutateRowsTs_result() throw() {}

  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : io(false), ia(false) {}
    bool io;
    bool ia;
  } __isset;

  bool operator == (const Hbase_mutateRowsTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_mutateRowsTs_presult {
 public:


  virtual ~Hbase_mutateRowsTs_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : io(false), ia(false) {}
    bool io;
    bool ia;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_atomicIncrement_args {
 public:

  Hbase_atomicIncrement_args() : tableName(""), row(""), column(""), value(0) {
  }

  virtual ~Hbase_atomicIncrement_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  int64_t value;

  struct __isset {
    __isset() : tableName(false), row(false), column(false), value(false) {}
    bool tableName;
    bool row;
    bool column;
    bool value;
  } __isset;

  bool operator == (const Hbase_atomicIncrement_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Hbase_atomicIncrement_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_atomicIncrement_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_atomicIncrement_pargs {
 public:


  virtual ~Hbase_atomicIncrement_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const int64_t* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_atomicIncrement_result {
 public:

  Hbase_atomicIncrement_result() : success(0) {
  }

  virtual ~Hbase_atomicIncrement_result() throw() {}

  int64_t success;
  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : success(false), io(false), ia(false) {}
    bool success;
    bool io;
    bool ia;
  } __isset;

  bool operator == (const Hbase_atomicIncrement_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_atomicIncrement_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_atomicIncrement_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_atomicIncrement_presult {
 public:


  virtual ~Hbase_atomicIncrement_presult() throw() {}

  int64_t* success;
  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : success(false), io(false), ia(false) {}
    bool success;
    bool io;
    bool ia;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_deleteAll_args {
 public:

  Hbase_deleteAll_args() : tableName(""), row(""), column("") {
  }

  virtual ~Hbase_deleteAll_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), column(false), attributes(false) {}
    bool tableName;
    bool row;
    bool column;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_deleteAll_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAll_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAll_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteAll_pargs {
 public:


  virtual ~Hbase_deleteAll_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteAll_result {
 public:

  Hbase_deleteAll_result() {
  }

  virtual ~Hbase_deleteAll_result() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  bool operator == (const Hbase_deleteAll_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAll_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAll_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteAll_presult {
 public:


  virtual ~Hbase_deleteAll_presult() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_deleteAllTs_args {
 public:

  Hbase_deleteAllTs_args() : tableName(""), row(""), column(""), timestamp(0) {
  }

  virtual ~Hbase_deleteAllTs_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), column(false), timestamp(false), attributes(false) {}
    bool tableName;
    bool row;
    bool column;
    bool timestamp;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_deleteAllTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteAllTs_pargs {
 public:


  virtual ~Hbase_deleteAllTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteAllTs_result {
 public:

  Hbase_deleteAllTs_result() {
  }

  virtual ~Hbase_deleteAllTs_result() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  bool operator == (const Hbase_deleteAllTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteAllTs_presult {
 public:


  virtual ~Hbase_deleteAllTs_presult() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_deleteAllRow_args {
 public:

  Hbase_deleteAllRow_args() : tableName(""), row("") {
  }

  virtual ~Hbase_deleteAllRow_args() throw() {}

  Text tableName;
  Text row;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), attributes(false) {}
    bool tableName;
    bool row;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_deleteAllRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteAllRow_pargs {
 public:


  virtual ~Hbase_deleteAllRow_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteAllRow_result {
 public:

  Hbase_deleteAllRow_result() {
  }

  virtual ~Hbase_deleteAllRow_result() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  bool operator == (const Hbase_deleteAllRow_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteAllRow_presult {
 public:


  virtual ~Hbase_deleteAllRow_presult() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_increment_args {
 public:

  Hbase_increment_args() {
  }

  virtual ~Hbase_increment_args() throw() {}

  TIncrement increment;

  struct __isset {
    __isset() : increment(false) {}
    bool increment;
  } __isset;

  bool operator == (const Hbase_increment_args & rhs) const
  {
    if (!(increment == rhs.increment))
      return false;
    return true;
  }
  bool operator != (const Hbase_increment_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_increment_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_increment_pargs {
 public:


  virtual ~Hbase_increment_pargs() throw() {}

  const TIncrement* increment;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_increment_result {
 public:

  Hbase_increment_result() {
  }

  virtual ~Hbase_increment_result() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  bool operator == (const Hbase_increment_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_increment_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_increment_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_increment_presult {
 public:


  virtual ~Hbase_increment_presult() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_incrementRows_args {
 public:

  Hbase_incrementRows_args() {
  }

  virtual ~Hbase_incrementRows_args() throw() {}

  std::vector<TIncrement>  increments;

  struct __isset {
    __isset() : increments(false) {}
    bool increments;
  } __isset;

  bool operator == (const Hbase_incrementRows_args & rhs) const
  {
    if (!(increments == rhs.increments))
      return false;
    return true;
  }
  bool operator != (const Hbase_incrementRows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_incrementRows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_incrementRows_pargs {
 public:


  virtual ~Hbase_incrementRows_pargs() throw() {}

  const std::vector<TIncrement> * increments;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_incrementRows_result {
 public:

  Hbase_incrementRows_result() {
  }

  virtual ~Hbase_incrementRows_result() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  bool operator == (const Hbase_incrementRows_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_incrementRows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_incrementRows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_incrementRows_presult {
 public:


  virtual ~Hbase_incrementRows_presult() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_deleteAllRowTs_args {
 public:

  Hbase_deleteAllRowTs_args() : tableName(""), row(""), timestamp(0) {
  }

  virtual ~Hbase_deleteAllRowTs_args() throw() {}

  Text tableName;
  Text row;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), row(false), timestamp(false), attributes(false) {}
    bool tableName;
    bool row;
    bool timestamp;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_deleteAllRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteAllRowTs_pargs {
 public:


  virtual ~Hbase_deleteAllRowTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteAllRowTs_result {
 public:

  Hbase_deleteAllRowTs_result() {
  }

  virtual ~Hbase_deleteAllRowTs_result() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  bool operator == (const Hbase_deleteAllRowTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_deleteAllRowTs_presult {
 public:


  virtual ~Hbase_deleteAllRowTs_presult() throw() {}

  IOError io;

  struct __isset {
    __isset() : io(false) {}
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_scannerOpenWithScan_args {
 public:

  Hbase_scannerOpenWithScan_args() : tableName("") {
  }

  virtual ~Hbase_scannerOpenWithScan_args() throw() {}

  Text tableName;
  TScan scan;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), scan(false), attributes(false) {}
    bool tableName;
    bool scan;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_scannerOpenWithScan_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(scan == rhs.scan))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithScan_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithScan_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenWithScan_pargs {
 public:


  virtual ~Hbase_scannerOpenWithScan_pargs() throw() {}

  const Text* tableName;
  const TScan* scan;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenWithScan_result {
 public:

  Hbase_scannerOpenWithScan_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithScan_result() throw() {}

  ScannerID success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_scannerOpenWithScan_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithScan_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithScan_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenWithScan_presult {
 public:


  virtual ~Hbase_scannerOpenWithScan_presult() throw() {}

  ScannerID* success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_scannerOpen_args {
 public:

  Hbase_scannerOpen_args() : tableName(""), startRow("") {
  }

  virtual ~Hbase_scannerOpen_args() throw() {}

  Text tableName;
  Text startRow;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), startRow(false), columns(false), attributes(false) {}
    bool tableName;
    bool startRow;
    bool columns;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_scannerOpen_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpen_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpen_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpen_pargs {
 public:


  virtual ~Hbase_scannerOpen_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpen_result {
 public:

  Hbase_scannerOpen_result() : success(0) {
  }

  virtual ~Hbase_scannerOpen_result() throw() {}

  ScannerID success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_scannerOpen_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpen_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpen_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpen_presult {
 public:


  virtual ~Hbase_scannerOpen_presult() throw() {}

  ScannerID* success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_scannerOpenWithStop_args {
 public:

  Hbase_scannerOpenWithStop_args() : tableName(""), startRow(""), stopRow("") {
  }

  virtual ~Hbase_scannerOpenWithStop_args() throw() {}

  Text tableName;
  Text startRow;
  Text stopRow;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), startRow(false), stopRow(false), columns(false), attributes(false) {}
    bool tableName;
    bool startRow;
    bool stopRow;
    bool columns;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_scannerOpenWithStop_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStop_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStop_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenWithStop_pargs {
 public:


  virtual ~Hbase_scannerOpenWithStop_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenWithStop_result {
 public:

  Hbase_scannerOpenWithStop_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStop_result() throw() {}

  ScannerID success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_scannerOpenWithStop_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStop_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStop_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenWithStop_presult {
 public:


  virtual ~Hbase_scannerOpenWithStop_presult() throw() {}

  ScannerID* success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_scannerOpenWithPrefix_args {
 public:

  Hbase_scannerOpenWithPrefix_args() : tableName(""), startAndPrefix("") {
  }

  virtual ~Hbase_scannerOpenWithPrefix_args() throw() {}

  Text tableName;
  Text startAndPrefix;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), startAndPrefix(false), columns(false), attributes(false) {}
    bool tableName;
    bool startAndPrefix;
    bool columns;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_scannerOpenWithPrefix_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startAndPrefix == rhs.startAndPrefix))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithPrefix_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithPrefix_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenWithPrefix_pargs {
 public:


  virtual ~Hbase_scannerOpenWithPrefix_pargs() throw() {}

  const Text* tableName;
  const Text* startAndPrefix;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenWithPrefix_result {
 public:

  Hbase_scannerOpenWithPrefix_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithPrefix_result() throw() {}

  ScannerID success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_scannerOpenWithPrefix_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithPrefix_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithPrefix_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenWithPrefix_presult {
 public:


  virtual ~Hbase_scannerOpenWithPrefix_presult() throw() {}

  ScannerID* success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_scannerOpenTs_args {
 public:

  Hbase_scannerOpenTs_args() : tableName(""), startRow(""), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenTs_args() throw() {}

  Text tableName;
  Text startRow;
  std::vector<Text>  columns;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), startRow(false), columns(false), timestamp(false), attributes(false) {}
    bool tableName;
    bool startRow;
    bool columns;
    bool timestamp;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_scannerOpenTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenTs_pargs {
 public:


  virtual ~Hbase_scannerOpenTs_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const std::vector<Text> * columns;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenTs_result {
 public:

  Hbase_scannerOpenTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenTs_result() throw() {}

  ScannerID success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_scannerOpenTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenTs_presult {
 public:


  virtual ~Hbase_scannerOpenTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_scannerOpenWithStopTs_args {
 public:

  Hbase_scannerOpenWithStopTs_args() : tableName(""), startRow(""), stopRow(""), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenWithStopTs_args() throw() {}

  Text tableName;
  Text startRow;
  Text stopRow;
  std::vector<Text>  columns;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  struct __isset {
    __isset() : tableName(false), startRow(false), stopRow(false), columns(false), timestamp(false), attributes(false) {}
    bool tableName;
    bool startRow;
    bool stopRow;
    bool columns;
    bool timestamp;
    bool attributes;
  } __isset;

  bool operator == (const Hbase_scannerOpenWithStopTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenWithStopTs_pargs {
 public:


  virtual ~Hbase_scannerOpenWithStopTs_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const std::vector<Text> * columns;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenWithStopTs_result {
 public:

  Hbase_scannerOpenWithStopTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStopTs_result() throw() {}

  ScannerID success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_scannerOpenWithStopTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerOpenWithStopTs_presult {
 public:


  virtual ~Hbase_scannerOpenWithStopTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_scannerGet_args {
 public:

  Hbase_scannerGet_args() : id(0) {
  }

  virtual ~Hbase_scannerGet_args() throw() {}

  ScannerID id;

  struct __isset {
    __isset() : id(false) {}
    bool id;
  } __isset;

  bool operator == (const Hbase_scannerGet_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerGet_pargs {
 public:


  virtual ~Hbase_scannerGet_pargs() throw() {}

  const ScannerID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerGet_result {
 public:

  Hbase_scannerGet_result() {
  }

  virtual ~Hbase_scannerGet_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : success(false), io(false), ia(false) {}
    bool success;
    bool io;
    bool ia;
  } __isset;

  bool operator == (const Hbase_scannerGet_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGet_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGet_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerGet_presult {
 public:


  virtual ~Hbase_scannerGet_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : success(false), io(false), ia(false) {}
    bool success;
    bool io;
    bool ia;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_scannerGetList_args {
 public:

  Hbase_scannerGetList_args() : id(0), nbRows(0) {
  }

  virtual ~Hbase_scannerGetList_args() throw() {}

  ScannerID id;
  int32_t nbRows;

  struct __isset {
    __isset() : id(false), nbRows(false) {}
    bool id;
    bool nbRows;
  } __isset;

  bool operator == (const Hbase_scannerGetList_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(nbRows == rhs.nbRows))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGetList_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGetList_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerGetList_pargs {
 public:


  virtual ~Hbase_scannerGetList_pargs() throw() {}

  const ScannerID* id;
  const int32_t* nbRows;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerGetList_result {
 public:

  Hbase_scannerGetList_result() {
  }

  virtual ~Hbase_scannerGetList_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : success(false), io(false), ia(false) {}
    bool success;
    bool io;
    bool ia;
  } __isset;

  bool operator == (const Hbase_scannerGetList_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGetList_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGetList_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerGetList_presult {
 public:


  virtual ~Hbase_scannerGetList_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : success(false), io(false), ia(false) {}
    bool success;
    bool io;
    bool ia;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_scannerClose_args {
 public:

  Hbase_scannerClose_args() : id(0) {
  }

  virtual ~Hbase_scannerClose_args() throw() {}

  ScannerID id;

  struct __isset {
    __isset() : id(false) {}
    bool id;
  } __isset;

  bool operator == (const Hbase_scannerClose_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerClose_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerClose_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerClose_pargs {
 public:


  virtual ~Hbase_scannerClose_pargs() throw() {}

  const ScannerID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerClose_result {
 public:

  Hbase_scannerClose_result() {
  }

  virtual ~Hbase_scannerClose_result() throw() {}

  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : io(false), ia(false) {}
    bool io;
    bool ia;
  } __isset;

  bool operator == (const Hbase_scannerClose_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerClose_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerClose_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_scannerClose_presult {
 public:


  virtual ~Hbase_scannerClose_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  struct __isset {
    __isset() : io(false), ia(false) {}
    bool io;
    bool ia;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getRowOrBefore_args {
 public:

  Hbase_getRowOrBefore_args() : tableName(""), row(""), family("") {
  }

  virtual ~Hbase_getRowOrBefore_args() throw() {}

  Text tableName;
  Text row;
  Text family;

  struct __isset {
    __isset() : tableName(false), row(false), family(false) {}
    bool tableName;
    bool row;
    bool family;
  } __isset;

  bool operator == (const Hbase_getRowOrBefore_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(family == rhs.family))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowOrBefore_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowOrBefore_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowOrBefore_pargs {
 public:


  virtual ~Hbase_getRowOrBefore_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* family;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowOrBefore_result {
 public:

  Hbase_getRowOrBefore_result() {
  }

  virtual ~Hbase_getRowOrBefore_result() throw() {}

  std::vector<TCell>  success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getRowOrBefore_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowOrBefore_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowOrBefore_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRowOrBefore_presult {
 public:


  virtual ~Hbase_getRowOrBefore_presult() throw() {}

  std::vector<TCell> * success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class Hbase_getRegionInfo_args {
 public:

  Hbase_getRegionInfo_args() : row("") {
  }

  virtual ~Hbase_getRegionInfo_args() throw() {}

  Text row;

  struct __isset {
    __isset() : row(false) {}
    bool row;
  } __isset;

  bool operator == (const Hbase_getRegionInfo_args & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRegionInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRegionInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRegionInfo_pargs {
 public:


  virtual ~Hbase_getRegionInfo_pargs() throw() {}

  const Text* row;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRegionInfo_result {
 public:

  Hbase_getRegionInfo_result() {
  }

  virtual ~Hbase_getRegionInfo_result() throw() {}

  TRegionInfo success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  bool operator == (const Hbase_getRegionInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRegionInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRegionInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class Hbase_getRegionInfo_presult {
 public:


  virtual ~Hbase_getRegionInfo_presult() throw() {}

  TRegionInfo* success;
  IOError io;

  struct __isset {
    __isset() : success(false), io(false) {}
    bool success;
    bool io;
  } __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class HbaseClient : virtual public HbaseIf {
 public:
  HbaseClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  HbaseClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void enableTable(const Bytes& tableName);
  void send_enableTable(const Bytes& tableName);
  void recv_enableTable();
  void disableTable(const Bytes& tableName);
  void send_disableTable(const Bytes& tableName);
  void recv_disableTable();
  bool isTableEnabled(const Bytes& tableName);
  void send_isTableEnabled(const Bytes& tableName);
  bool recv_isTableEnabled();
  void compact(const Bytes& tableNameOrRegionName);
  void send_compact(const Bytes& tableNameOrRegionName);
  void recv_compact();
  void majorCompact(const Bytes& tableNameOrRegionName);
  void send_majorCompact(const Bytes& tableNameOrRegionName);
  void recv_majorCompact();
  void getTableNames(std::vector<Text> & _return);
  void send_getTableNames();
  void recv_getTableNames(std::vector<Text> & _return);
  void getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return, const Text& tableName);
  void send_getColumnDescriptors(const Text& tableName);
  void recv_getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return);
  void getTableRegions(std::vector<TRegionInfo> & _return, const Text& tableName);
  void send_getTableRegions(const Text& tableName);
  void recv_getTableRegions(std::vector<TRegionInfo> & _return);
  void createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies);
  void send_createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies);
  void recv_createTable();
  void deleteTable(const Text& tableName);
  void send_deleteTable(const Text& tableName);
  void recv_deleteTable();
  void get(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes);
  void send_get(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes);
  void recv_get(std::vector<TCell> & _return);
  void getVer(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions, const std::map<Text, Text> & attributes);
  void send_getVer(const Text& tableName, const Text& row, const Text& column, const int32_t numVersions, const std::map<Text, Text> & attributes);
  void recv_getVer(std::vector<TCell> & _return);
  void getVerTs(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions, const std::map<Text, Text> & attributes);
  void send_getVerTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions, const std::map<Text, Text> & attributes);
  void recv_getVerTs(std::vector<TCell> & _return);
  void getRow(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void send_getRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void recv_getRow(std::vector<TRowResult> & _return);
  void getRowWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_getRowWithColumns(const Text& tableName, const Text& row, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void recv_getRowWithColumns(std::vector<TRowResult> & _return);
  void getRowTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_getRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_getRowTs(std::vector<TRowResult> & _return);
  void getRowWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_getRowWithColumnsTs(const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_getRowWithColumnsTs(std::vector<TRowResult> & _return);
  void getRows(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::map<Text, Text> & attributes);
  void send_getRows(const Text& tableName, const std::vector<Text> & rows, const std::map<Text, Text> & attributes);
  void recv_getRows(std::vector<TRowResult> & _return);
  void getRowsWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_getRowsWithColumns(const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void recv_getRowsWithColumns(std::vector<TRowResult> & _return);
  void getRowsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_getRowsTs(const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_getRowsTs(std::vector<TRowResult> & _return);
  void getRowsWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_getRowsWithColumnsTs(const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_getRowsWithColumnsTs(std::vector<TRowResult> & _return);
  void mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes);
  void send_mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes);
  void recv_mutateRow();
  void mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_mutateRowTs();
  void mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes);
  void send_mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes);
  void recv_mutateRows();
  void mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_mutateRowsTs();
  int64_t atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value);
  void send_atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value);
  int64_t recv_atomicIncrement();
  void deleteAll(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes);
  void send_deleteAll(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes);
  void recv_deleteAll();
  void deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_deleteAllTs();
  void deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void send_deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void recv_deleteAllRow();
  void increment(const TIncrement& increment);
  void send_increment(const TIncrement& increment);
  void recv_increment();
  void incrementRows(const std::vector<TIncrement> & increments);
  void send_incrementRows(const std::vector<TIncrement> & increments);
  void recv_incrementRows();
  void deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_deleteAllRowTs();
  ScannerID scannerOpenWithScan(const Text& tableName, const TScan& scan, const std::map<Text, Text> & attributes);
  void send_scannerOpenWithScan(const Text& tableName, const TScan& scan, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenWithScan();
  ScannerID scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpen();
  ScannerID scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenWithStop();
  ScannerID scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenWithPrefix();
  ScannerID scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenTs();
  ScannerID scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenWithStopTs();
  void scannerGet(std::vector<TRowResult> & _return, const ScannerID id);
  void send_scannerGet(const ScannerID id);
  void recv_scannerGet(std::vector<TRowResult> & _return);
  void scannerGetList(std::vector<TRowResult> & _return, const ScannerID id, const int32_t nbRows);
  void send_scannerGetList(const ScannerID id, const int32_t nbRows);
  void recv_scannerGetList(std::vector<TRowResult> & _return);
  void scannerClose(const ScannerID id);
  void send_scannerClose(const ScannerID id);
  void recv_scannerClose();
  void getRowOrBefore(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& family);
  void send_getRowOrBefore(const Text& tableName, const Text& row, const Text& family);
  void recv_getRowOrBefore(std::vector<TCell> & _return);
  void getRegionInfo(TRegionInfo& _return, const Text& row);
  void send_getRegionInfo(const Text& row);
  void recv_getRegionInfo(TRegionInfo& _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class HbaseProcessor : virtual public ::apache::thrift::TProcessor {
 protected:
  boost::shared_ptr<HbaseIf> iface_;
  virtual bool process_fn(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid);
 private:
  std::map<std::string, void (HbaseProcessor::*)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*)> processMap_;
  void process_enableTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_disableTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_isTableEnabled(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_compact(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_majorCompact(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getTableNames(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getColumnDescriptors(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getTableRegions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_createTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_deleteTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_get(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getVer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getVerTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getRow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getRowWithColumns(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getRowTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getRowWithColumnsTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getRows(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getRowsWithColumns(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getRowsTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getRowsWithColumnsTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_mutateRow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_mutateRowTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_mutateRows(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_mutateRowsTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_atomicIncrement(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_deleteAll(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_deleteAllTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_deleteAllRow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_increment(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_incrementRows(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_deleteAllRowTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_scannerOpenWithScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_scannerOpen(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_scannerOpenWithStop(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_scannerOpenWithPrefix(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_scannerOpenTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_scannerOpenWithStopTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_scannerGet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_scannerGetList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_scannerClose(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getRowOrBefore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getRegionInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
 public:
  HbaseProcessor(boost::shared_ptr<HbaseIf> iface) :
    iface_(iface) {
    processMap_["enableTable"] = &HbaseProcessor::process_enableTable;
    processMap_["disableTable"] = &HbaseProcessor::process_disableTable;
    processMap_["isTableEnabled"] = &HbaseProcessor::process_isTableEnabled;
    processMap_["compact"] = &HbaseProcessor::process_compact;
    processMap_["majorCompact"] = &HbaseProcessor::process_majorCompact;
    processMap_["getTableNames"] = &HbaseProcessor::process_getTableNames;
    processMap_["getColumnDescriptors"] = &HbaseProcessor::process_getColumnDescriptors;
    processMap_["getTableRegions"] = &HbaseProcessor::process_getTableRegions;
    processMap_["createTable"] = &HbaseProcessor::process_createTable;
    processMap_["deleteTable"] = &HbaseProcessor::process_deleteTable;
    processMap_["get"] = &HbaseProcessor::process_get;
    processMap_["getVer"] = &HbaseProcessor::process_getVer;
    processMap_["getVerTs"] = &HbaseProcessor::process_getVerTs;
    processMap_["getRow"] = &HbaseProcessor::process_getRow;
    processMap_["getRowWithColumns"] = &HbaseProcessor::process_getRowWithColumns;
    processMap_["getRowTs"] = &HbaseProcessor::process_getRowTs;
    processMap_["getRowWithColumnsTs"] = &HbaseProcessor::process_getRowWithColumnsTs;
    processMap_["getRows"] = &HbaseProcessor::process_getRows;
    processMap_["getRowsWithColumns"] = &HbaseProcessor::process_getRowsWithColumns;
    processMap_["getRowsTs"] = &HbaseProcessor::process_getRowsTs;
    processMap_["getRowsWithColumnsTs"] = &HbaseProcessor::process_getRowsWithColumnsTs;
    processMap_["mutateRow"] = &HbaseProcessor::process_mutateRow;
    processMap_["mutateRowTs"] = &HbaseProcessor::process_mutateRowTs;
    processMap_["mutateRows"] = &HbaseProcessor::process_mutateRows;
    processMap_["mutateRowsTs"] = &HbaseProcessor::process_mutateRowsTs;
    processMap_["atomicIncrement"] = &HbaseProcessor::process_atomicIncrement;
    processMap_["deleteAll"] = &HbaseProcessor::process_deleteAll;
    processMap_["deleteAllTs"] = &HbaseProcessor::process_deleteAllTs;
    processMap_["deleteAllRow"] = &HbaseProcessor::process_deleteAllRow;
    processMap_["increment"] = &HbaseProcessor::process_increment;
    processMap_["incrementRows"] = &HbaseProcessor::process_incrementRows;
    processMap_["deleteAllRowTs"] = &HbaseProcessor::process_deleteAllRowTs;
    processMap_["scannerOpenWithScan"] = &HbaseProcessor::process_scannerOpenWithScan;
    processMap_["scannerOpen"] = &HbaseProcessor::process_scannerOpen;
    processMap_["scannerOpenWithStop"] = &HbaseProcessor::process_scannerOpenWithStop;
    processMap_["scannerOpenWithPrefix"] = &HbaseProcessor::process_scannerOpenWithPrefix;
    processMap_["scannerOpenTs"] = &HbaseProcessor::process_scannerOpenTs;
    processMap_["scannerOpenWithStopTs"] = &HbaseProcessor::process_scannerOpenWithStopTs;
    processMap_["scannerGet"] = &HbaseProcessor::process_scannerGet;
    processMap_["scannerGetList"] = &HbaseProcessor::process_scannerGetList;
    processMap_["scannerClose"] = &HbaseProcessor::process_scannerClose;
    processMap_["getRowOrBefore"] = &HbaseProcessor::process_getRowOrBefore;
    processMap_["getRegionInfo"] = &HbaseProcessor::process_getRegionInfo;
  }

  virtual bool process(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot);
  virtual ~HbaseProcessor() {}
};

class HbaseMultiface : virtual public HbaseIf {
 public:
  HbaseMultiface(std::vector<boost::shared_ptr<HbaseIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~HbaseMultiface() {}
 protected:
  std::vector<boost::shared_ptr<HbaseIf> > ifaces_;
  HbaseMultiface() {}
  void add(boost::shared_ptr<HbaseIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void enableTable(const Bytes& tableName) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->enableTable(tableName);
    }
  }

  void disableTable(const Bytes& tableName) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->disableTable(tableName);
    }
  }

  bool isTableEnabled(const Bytes& tableName) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->isTableEnabled(tableName);
      } else {
        ifaces_[i]->isTableEnabled(tableName);
      }
    }
  }

  void compact(const Bytes& tableNameOrRegionName) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->compact(tableNameOrRegionName);
    }
  }

  void majorCompact(const Bytes& tableNameOrRegionName) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->majorCompact(tableNameOrRegionName);
    }
  }

  void getTableNames(std::vector<Text> & _return) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getTableNames(_return);
        return;
      } else {
        ifaces_[i]->getTableNames(_return);
      }
    }
  }

  void getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return, const Text& tableName) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getColumnDescriptors(_return, tableName);
        return;
      } else {
        ifaces_[i]->getColumnDescriptors(_return, tableName);
      }
    }
  }

  void getTableRegions(std::vector<TRegionInfo> & _return, const Text& tableName) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getTableRegions(_return, tableName);
        return;
      } else {
        ifaces_[i]->getTableRegions(_return, tableName);
      }
    }
  }

  void createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->createTable(tableName, columnFamilies);
    }
  }

  void deleteTable(const Text& tableName) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->deleteTable(tableName);
    }
  }

  void get(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get(_return, tableName, row, column, attributes);
        return;
      } else {
        ifaces_[i]->get(_return, tableName, row, column, attributes);
      }
    }
  }

  void getVer(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getVer(_return, tableName, row, column, numVersions, attributes);
        return;
      } else {
        ifaces_[i]->getVer(_return, tableName, row, column, numVersions, attributes);
      }
    }
  }

  void getVerTs(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getVerTs(_return, tableName, row, column, timestamp, numVersions, attributes);
        return;
      } else {
        ifaces_[i]->getVerTs(_return, tableName, row, column, timestamp, numVersions, attributes);
      }
    }
  }

  void getRow(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRow(_return, tableName, row, attributes);
        return;
      } else {
        ifaces_[i]->getRow(_return, tableName, row, attributes);
      }
    }
  }

  void getRowWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowWithColumns(_return, tableName, row, columns, attributes);
        return;
      } else {
        ifaces_[i]->getRowWithColumns(_return, tableName, row, columns, attributes);
      }
    }
  }

  void getRowTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowTs(_return, tableName, row, timestamp, attributes);
        return;
      } else {
        ifaces_[i]->getRowTs(_return, tableName, row, timestamp, attributes);
      }
    }
  }

  void getRowWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowWithColumnsTs(_return, tableName, row, columns, timestamp, attributes);
        return;
      } else {
        ifaces_[i]->getRowWithColumnsTs(_return, tableName, row, columns, timestamp, attributes);
      }
    }
  }

  void getRows(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRows(_return, tableName, rows, attributes);
        return;
      } else {
        ifaces_[i]->getRows(_return, tableName, rows, attributes);
      }
    }
  }

  void getRowsWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowsWithColumns(_return, tableName, rows, columns, attributes);
        return;
      } else {
        ifaces_[i]->getRowsWithColumns(_return, tableName, rows, columns, attributes);
      }
    }
  }

  void getRowsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowsTs(_return, tableName, rows, timestamp, attributes);
        return;
      } else {
        ifaces_[i]->getRowsTs(_return, tableName, rows, timestamp, attributes);
      }
    }
  }

  void getRowsWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowsWithColumnsTs(_return, tableName, rows, columns, timestamp, attributes);
        return;
      } else {
        ifaces_[i]->getRowsWithColumnsTs(_return, tableName, rows, columns, timestamp, attributes);
      }
    }
  }

  void mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->mutateRow(tableName, row, mutations, attributes);
    }
  }

  void mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->mutateRowTs(tableName, row, mutations, timestamp, attributes);
    }
  }

  void mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->mutateRows(tableName, rowBatches, attributes);
    }
  }

  void mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->mutateRowsTs(tableName, rowBatches, timestamp, attributes);
    }
  }

  int64_t atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->atomicIncrement(tableName, row, column, value);
      } else {
        ifaces_[i]->atomicIncrement(tableName, row, column, value);
      }
    }
  }

  void deleteAll(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->deleteAll(tableName, row, column, attributes);
    }
  }

  void deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->deleteAllTs(tableName, row, column, timestamp, attributes);
    }
  }

  void deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->deleteAllRow(tableName, row, attributes);
    }
  }

  void increment(const TIncrement& increment) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->increment(increment);
    }
  }

  void incrementRows(const std::vector<TIncrement> & increments) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->incrementRows(increments);
    }
  }

  void deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->deleteAllRowTs(tableName, row, timestamp, attributes);
    }
  }

  ScannerID scannerOpenWithScan(const Text& tableName, const TScan& scan, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithScan(tableName, scan, attributes);
      } else {
        ifaces_[i]->scannerOpenWithScan(tableName, scan, attributes);
      }
    }
  }

  ScannerID scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpen(tableName, startRow, columns, attributes);
      } else {
        ifaces_[i]->scannerOpen(tableName, startRow, columns, attributes);
      }
    }
  }

  ScannerID scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithStop(tableName, startRow, stopRow, columns, attributes);
      } else {
        ifaces_[i]->scannerOpenWithStop(tableName, startRow, stopRow, columns, attributes);
      }
    }
  }

  ScannerID scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes);
      } else {
        ifaces_[i]->scannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes);
      }
    }
  }

  ScannerID scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenTs(tableName, startRow, columns, timestamp, attributes);
      } else {
        ifaces_[i]->scannerOpenTs(tableName, startRow, columns, timestamp, attributes);
      }
    }
  }

  ScannerID scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes);
      } else {
        ifaces_[i]->scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes);
      }
    }
  }

  void scannerGet(std::vector<TRowResult> & _return, const ScannerID id) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->scannerGet(_return, id);
        return;
      } else {
        ifaces_[i]->scannerGet(_return, id);
      }
    }
  }

  void scannerGetList(std::vector<TRowResult> & _return, const ScannerID id, const int32_t nbRows) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->scannerGetList(_return, id, nbRows);
        return;
      } else {
        ifaces_[i]->scannerGetList(_return, id, nbRows);
      }
    }
  }

  void scannerClose(const ScannerID id) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->scannerClose(id);
    }
  }

  void getRowOrBefore(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& family) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRowOrBefore(_return, tableName, row, family);
        return;
      } else {
        ifaces_[i]->getRowOrBefore(_return, tableName, row, family);
      }
    }
  }

  void getRegionInfo(TRegionInfo& _return, const Text& row) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getRegionInfo(_return, row);
        return;
      } else {
        ifaces_[i]->getRegionInfo(_return, row);
      }
    }
  }

};

}}}} // namespace

#endif
